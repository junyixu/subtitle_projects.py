#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright ¬© 2025 Junyi Xu <jyxu@mail.ustc.edu.cn>
#
# Distributed under terms of the MIT license.
"""
Professional Subtitle Translation System
ÂèÇËÄÉ gpt-subtrans Âíå VideoCaptioner ÁöÑÊû∂ÊûÑËÆæËÆ°

È°πÁõÆÁâπÁÇπ:
- Ê®°ÂùóÂåñËÆæËÆ°ÔºåÊòì‰∫éÊâ©Â±ï
- È°πÁõÆÁÆ°ÁêÜÁ≥ªÁªüÔºåÊîØÊåÅÊöÇÂÅúÊÅ¢Â§ç
- Êô∫ËÉΩÊâπÂ§ÑÁêÜÂíåÈîôËØØÊÅ¢Â§ç
- Â§öLLMÊèê‰æõÂïÜÊîØÊåÅ
- ÂÆåÊï¥ÁöÑÊó•ÂøóÂíåËøõÂ∫¶ËøΩË∏™

‰æùËµñÂÆâË£Ö:
pip install openai anthropic google-generativeai pysrt aiohttp rich typer pydantic
"""

import asyncio
import json
import re
import time
import os
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any
from enum import Enum
from dataclasses import dataclass, asdict
import logging
import hashlib

import pysrt
import typer
from rich.console import Console
from rich.progress import Progress, TaskID, SpinnerColumn, TextColumn, BarColumn, TimeRemainingColumn
from rich.table import Table
from rich.panel import Panel
from rich.tree import Tree
import aiohttp
from pydantic import BaseModel, Field

# LLM ÂÆ¢Êà∑Á´ØÂØºÂÖ•
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False

try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False

console = Console()
app = typer.Typer(help="üé¨ Professional Subtitle Translation System")

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('subtitle_translator.log'),
        logging.StreamHandler()
    ])
logger = logging.getLogger(__name__)


class TranslationStatus(str, Enum):
    """ÁøªËØëÁä∂ÊÄÅÊûö‰∏æ"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    PAUSED = "paused"


class LLMProvider(str, Enum):
    """LLMÊèê‰æõÂïÜÊûö‰∏æ"""
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    GEMINI = "gemini"
    DEEPSEEK = "deepseek"
    ZHIPU = "zhipu"
    MOONSHOT = "moonshot"
    QWEN = "qwen"
    OLLAMA = "ollama"


@dataclass
class SubtitleSegment:
    """Â≠óÂπïÁâáÊÆµÊï∞ÊçÆÁ±ª"""
    index: int
    start: timedelta
    end: timedelta
    text: str
    translation: str = ""
    status: TranslationStatus = TranslationStatus.PENDING
    retry_count: int = 0
    error_message: str = ""

    @property
    def duration(self) -> float:
        return (self.end - self.start).total_seconds()

    @property
    def char_count(self) -> int:
        return len(self.text)

    @property
    def hash(self) -> str:
        """ÁîüÊàêÁâáÊÆµÁöÑÂîØ‰∏ÄÊ†áËØÜ"""
        content = f"{self.index}_{self.start}_{self.end}_{self.text}"
        return hashlib.md5(content.encode()).hexdigest()[:8]

    def to_dict(self) -> Dict:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏ÔºåÁî®‰∫éJSONÂ∫èÂàóÂåñ"""
        return {
            'index': self.index,
            'start': self.start.total_seconds(),
            'end': self.end.total_seconds(),
            'text': self.text,
            'translation': self.translation,
            'status': self.status.value,
            'retry_count': self.retry_count,
            'error_message': self.error_message
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'SubtitleSegment':
        """‰ªéÂ≠óÂÖ∏ÂàõÂª∫ÂØπË±°"""
        return cls(index=data['index'],
                   start=timedelta(seconds=data['start']),
                   end=timedelta(seconds=data['end']),
                   text=data['text'],
                   translation=data.get('translation', ''),
                   status=TranslationStatus(data.get('status', 'pending')),
                   retry_count=data.get('retry_count', 0),
                   error_message=data.get('error_message', ''))


class ProjectConfig(BaseModel):
    """È°πÁõÆÈÖçÁΩÆÊ®°Âûã"""
    name: str
    source_file: str
    target_language: str = "chinese"
    llm_provider: LLMProvider
    model: str
    temperature: float = 0.3
    max_tokens: int = 2000
    batch_size: int = 10
    max_retry: int = 3
    context_window: int = 15
    custom_prompt: Optional[str] = None
    glossary: Dict[str, str] = Field(default_factory=dict)

    class Config:
        use_enum_values = True


class TranslationProject:
    """ÁøªËØëÈ°πÁõÆÁÆ°ÁêÜÁ±ª"""

    def __init__(self, config: ProjectConfig, project_dir: Path):
        self.config = config
        self.project_dir = project_dir
        self.project_dir.mkdir(parents=True, exist_ok=True)

        # È°πÁõÆÊñá‰ª∂Ë∑ØÂæÑ
        self.segments_file = self.project_dir / "segments.json"
        self.progress_file = self.project_dir / "progress.json"
        self.config_file = self.project_dir / "config.json"
        self.log_file = self.project_dir / "translation.log"

        # ÂÜÖÈÉ®Áä∂ÊÄÅ
        self.segments: List[SubtitleSegment] = []
        self.start_time: Optional[datetime] = None
        self.pause_time: Optional[datetime] = None
        self.total_cost: float = 0.0

        # ËÆæÁΩÆÈ°πÁõÆÁ∫ßÊó•Âøó
        self.setup_project_logger()

    def setup_project_logger(self):
        """ËÆæÁΩÆÈ°πÁõÆ‰∏ìÁî®Êó•Âøó"""
        self.logger = logging.getLogger(f"project_{self.config.name}")
        handler = logging.FileHandler(self.log_file)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)

    def save_config(self):
        """‰øùÂ≠òÈ°πÁõÆÈÖçÁΩÆ"""
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self.config.model_dump(),
                      f,
                      indent=2,
                      ensure_ascii=False)

    def load_segments(self) -> bool:
        """Âä†ËΩΩÂ≠óÂπïÁâáÊÆµ"""
        if self.segments_file.exists():
            with open(self.segments_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.segments = [
                    SubtitleSegment.from_dict(item) for item in data
                ]
            return True
        return False

    def save_segments(self):
        """‰øùÂ≠òÂ≠óÂπïÁâáÊÆµ"""
        data = [seg.to_dict() for seg in self.segments]
        with open(self.segments_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def load_progress(self) -> Dict:
        """Âä†ËΩΩËøõÂ∫¶‰ø°ÊÅØ"""
        if self.progress_file.exists():
            with open(self.progress_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}

    def save_progress(self):
        """‰øùÂ≠òËøõÂ∫¶‰ø°ÊÅØ"""
        progress_data = {
            'total_segments':
            len(self.segments),
            'completed_segments':
            len([
                s for s in self.segments
                if s.status == TranslationStatus.COMPLETED
            ]),
            'failed_segments':
            len([
                s for s in self.segments
                if s.status == TranslationStatus.FAILED
            ]),
            'start_time':
            self.start_time.isoformat() if self.start_time else None,
            'pause_time':
            self.pause_time.isoformat() if self.pause_time else None,
            'total_cost':
            self.total_cost,
            'completion_rate':
            self.get_completion_rate()
        }

        with open(self.progress_file, 'w', encoding='utf-8') as f:
            json.dump(progress_data, f, indent=2, ensure_ascii=False)

    def get_completion_rate(self) -> float:
        """Ëé∑ÂèñÂÆåÊàêÁéá"""
        if not self.segments:
            return 0.0
        completed = len([
            s for s in self.segments if s.status == TranslationStatus.COMPLETED
        ])
        return completed / len(self.segments) * 100

    def get_pending_segments(self) -> List[SubtitleSegment]:
        """Ëé∑ÂèñÂæÖÁøªËØëÁöÑÁâáÊÆµ"""
        return [
            s for s in self.segments if s.status in
            [TranslationStatus.PENDING, TranslationStatus.FAILED]
        ]

    def get_failed_segments(self) -> List[SubtitleSegment]:
        """Ëé∑ÂèñÂ§±Ë¥•ÁöÑÁâáÊÆµ"""
        return [
            s for s in self.segments if s.status == TranslationStatus.FAILED
        ]


class LLMClientManager:
    """LLMÂÆ¢Êà∑Á´ØÁÆ°ÁêÜÂô®"""

    def __init__(self):
        self.providers = {
            LLMProvider.OPENAI: self._create_openai_client,
            LLMProvider.ANTHROPIC: self._create_anthropic_client,
            LLMProvider.GEMINI: self._create_gemini_client,
            LLMProvider.DEEPSEEK: self._create_openai_compatible_client,
            LLMProvider.ZHIPU: self._create_openai_compatible_client,
            LLMProvider.MOONSHOT: self._create_openai_compatible_client,
            LLMProvider.QWEN: self._create_openai_compatible_client,
            LLMProvider.OLLAMA: self._create_ollama_client,
        }

        self.endpoints = {
            LLMProvider.DEEPSEEK: "https://poloai.top/v1",
            LLMProvider.ZHIPU: "https://open.bigmodel.cn/api/paas/v4",
            LLMProvider.MOONSHOT: "https://api.moonshot.cn/v1",
            LLMProvider.QWEN:
            "https://dashscope.aliyuncs.com/compatible-mode/v1"
        }

        self.default_models = {
            LLMProvider.OPENAI: "gpt-4o-mini",
            LLMProvider.ANTHROPIC: "claude-3-5-sonnet-20241022",
            LLMProvider.GEMINI: "gemini-1.5-flash",
            LLMProvider.DEEPSEEK: "deepseek-v3",
            LLMProvider.ZHIPU: "glm-4-air",
            LLMProvider.MOONSHOT: "moonshot-v1-8k",
            LLMProvider.QWEN: "qwen-turbo",
            LLMProvider.OLLAMA: "qwen2.5:14b"
        }

    def create_client(self, provider: LLMProvider, **kwargs):
        """ÂàõÂª∫LLMÂÆ¢Êà∑Á´Ø"""
        if provider not in self.providers:
            raise ValueError(f"‰∏çÊîØÊåÅÁöÑÊèê‰æõÂïÜ: {provider}")

        # ‰∏∫OpenAIÂÖºÂÆπÂÆ¢Êà∑Á´Ø‰º†ÈÄíproviderÂèÇÊï∞
        if provider in [
                LLMProvider.DEEPSEEK, LLMProvider.ZHIPU, LLMProvider.MOONSHOT,
                LLMProvider.QWEN
        ]:
            return self.providers[provider](provider, **kwargs)
        else:
            return self.providers[provider](**kwargs)

    def _create_openai_client(self, api_key: str, **kwargs):
        """ÂàõÂª∫OpenAIÂÆ¢Êà∑Á´Ø"""
        if not OPENAI_AVAILABLE:
            raise ImportError("ËØ∑ÂÆâË£Ö: pip install openai")
        return openai.AsyncOpenAI(api_key=api_key)

    def _create_anthropic_client(self, api_key: str, **kwargs):
        """ÂàõÂª∫AnthropicÂÆ¢Êà∑Á´Ø"""
        if not ANTHROPIC_AVAILABLE:
            raise ImportError("ËØ∑ÂÆâË£Ö: pip install anthropic")
        return anthropic.AsyncAnthropic(api_key=api_key)

    def _create_gemini_client(self, api_key: str, model: str = None, **kwargs):
        """ÂàõÂª∫GeminiÂÆ¢Êà∑Á´Ø"""
        if not GEMINI_AVAILABLE:
            raise ImportError("ËØ∑ÂÆâË£Ö: pip install google-generativeai")
        genai.configure(api_key=api_key)
        return genai.GenerativeModel(
            model or self.default_models[LLMProvider.GEMINI])

    def _create_openai_compatible_client(self, provider: LLMProvider,
                                         api_key: str, **kwargs):
        """ÂàõÂª∫OpenAIÂÖºÂÆπÂÆ¢Êà∑Á´Ø"""
        if not OPENAI_AVAILABLE:
            raise ImportError("ËØ∑ÂÆâË£Ö: pip install openai")

        base_url = self.endpoints[provider]
        return openai.AsyncOpenAI(api_key=api_key, base_url=base_url)

    def _create_ollama_client(self,
                              base_url: str = "http://localhost:11434",
                              **kwargs):
        """ÂàõÂª∫OllamaÂÆ¢Êà∑Á´Ø"""
        return {"base_url": base_url, "type": "ollama"}

    def get_default_model(self, provider: LLMProvider) -> str:
        """Ëé∑ÂèñÈªòËÆ§Ê®°Âûã"""
        return self.default_models.get(provider, "unknown")


class TranslationEngine:
    """ÁøªËØëÂºïÊìé"""

    def __init__(self, project: TranslationProject):
        self.project = project
        self.config = project.config
        self.logger = project.logger

        # ÂàùÂßãÂåñLLMÂÆ¢Êà∑Á´Ø
        self.client_manager = LLMClientManager()
        self.client = None
        self.session = None  # Áî®‰∫éHTTPËØ∑Ê±Ç

        # ÁøªËØëÁªüËÆ°
        self.api_calls = 0
        self.total_tokens = 0
        self.errors = []

    async def initialize(self, api_key: str):
        """ÂàùÂßãÂåñÁøªËØëÂºïÊìé"""
        try:
            # ÂàõÂª∫LLMÂÆ¢Êà∑Á´Ø
            if self.config.llm_provider == LLMProvider.OLLAMA:
                self.client = self.client_manager.create_client(
                    self.config.llm_provider,
                    base_url="http://localhost:11434")
                self.session = aiohttp.ClientSession()
            else:
                self.client = self.client_manager.create_client(
                    self.config.llm_provider,
                    api_key=api_key,
                    model=self.config.model)

            self.logger.info(f"Â∑≤ÂàùÂßãÂåñ {self.config.llm_provider} ÂÆ¢Êà∑Á´Ø")

        except Exception as e:
            self.logger.error(f"ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            raise

    def create_translation_prompt(self,
                                  segments: List[SubtitleSegment],
                                  context: str = "") -> str:
        """ÂàõÂª∫ÁøªËØëÊèêÁ§∫ËØç"""
        # Âü∫Á°ÄÊèêÁ§∫ËØç
        base_prompt = f"""‰Ω†ÊòØ‰∏ì‰∏öÁöÑ{self.config.target_language}Â≠óÂπïÁøªËØë‰∏ìÂÆ∂„ÄÇ

ÁøªËØëË¶ÅÊ±ÇÔºö
1. ‰øùÊåÅÂéüÊÑèÂíåËØ≠Ë∞ÉÔºå‰ΩøÁî®Ëá™ÁÑ∂ÁöÑ‰∏≠ÊñáË°®Ëææ
2. ËÄÉËôëÂ≠óÂπïÊòæÁ§∫ÈôêÂà∂ÔºåÁÆÄÊ¥ÅÂáÜÁ°Æ
3. ‰øùÊåÅÊó∂Èó¥ÊÆµÂÜÖÁöÑËØ≠‰πâËøûË¥ØÊÄß
4. ÈÄÇÂ∫î‰∏≠ÊñáËßÇ‰ºóÁöÑÊñáÂåñËÉåÊôØ
5. ‰øùÊåÅËßíËâ≤ÂØπËØùÁöÑ‰∏ÄËá¥ÊÄß

"""

        # Ê∑ªÂä†ÊúØËØ≠Ë°®
        if self.config.glossary:
            base_prompt += "\n‰∏ì‰∏öÊúØËØ≠ÂØπÁÖß:\n"
            for en, zh in self.config.glossary.items():
                base_prompt += f"- {en} ‚Üí {zh}\n"

        # Ê∑ªÂä†Ëá™ÂÆö‰πâÊèêÁ§∫
        if self.config.custom_prompt:
            base_prompt += f"\nÁâπÊÆäË¶ÅÊ±ÇÔºö{self.config.custom_prompt}\n"

        # Ê∑ªÂä†‰∏ä‰∏ãÊñá
        if context:
            base_prompt += f"\n‰∏ä‰∏ãÊñá‰ø°ÊÅØÔºö{context}\n"

        # Ê∑ªÂä†ÂæÖÁøªËØëÂÜÖÂÆπ
        base_prompt += "\nËØ∑ÁøªËØë‰ª•‰∏ãÂ≠óÂπïÔºåÊåâÁºñÂè∑È°∫Â∫èËøîÂõûÔºö\n\n"

        for segment in segments:
            base_prompt += f"{segment.index}. {segment.text}\n"

        base_prompt += "\nÁøªËØëÁªìÊûúÔºàÊØèË°å‰∏Ä‰∏™ÁøªËØëÔºâÔºö"

        return base_prompt

    async def translate_batch(self,
                              segments: List[SubtitleSegment],
                              context: str = "") -> List[str]:
        """ÊâπÈáèÁøªËØë"""
        prompt = self.create_translation_prompt(segments, context)

        try:
            if self.config.llm_provider == LLMProvider.OPENAI:
                return await self._translate_openai(prompt, len(segments))
            elif self.config.llm_provider == LLMProvider.ANTHROPIC:
                return await self._translate_anthropic(prompt, len(segments))
            elif self.config.llm_provider == LLMProvider.GEMINI:
                return await self._translate_gemini(prompt, len(segments))
            elif self.config.llm_provider in [
                    LLMProvider.DEEPSEEK, LLMProvider.ZHIPU,
                    LLMProvider.MOONSHOT, LLMProvider.QWEN
            ]:
                return await self._translate_openai_compatible(
                    prompt, len(segments))
            elif self.config.llm_provider == LLMProvider.OLLAMA:
                return await self._translate_ollama(prompt, len(segments))

        except Exception as e:
            self.logger.error(f"ÊâπÈáèÁøªËØëÂ§±Ë¥•: {e}")
            self.errors.append(str(e))
            return [""] * len(segments)

    async def _translate_openai(self, prompt: str,
                                segment_count: int) -> List[str]:
        """OpenAIÁøªËØë"""
        response = await self.client.chat.completions.create(
            model=self.config.model,
            messages=[{
                "role": "user",
                "content": prompt
            }],
            max_tokens=self.config.max_tokens,
            temperature=self.config.temperature)

        self.api_calls += 1
        self.total_tokens += response.usage.total_tokens

        content = response.choices[0].message.content
        return self._parse_translation_response(content, segment_count)

    async def _translate_anthropic(self, prompt: str,
                                   segment_count: int) -> List[str]:
        """AnthropicÁøªËØë"""
        response = await self.client.messages.create(
            model=self.config.model,
            max_tokens=self.config.max_tokens,
            temperature=self.config.temperature,
            messages=[{
                "role": "user",
                "content": prompt
            }])

        self.api_calls += 1
        # AnthropicÊöÇÊó∂Ê≤°Êúâusage‰ø°ÊÅØÔºå‰º∞ÁÆó
        self.total_tokens += len(prompt) + self.config.max_tokens

        content = response.content[0].text
        return self._parse_translation_response(content, segment_count)

    async def _translate_gemini(self, prompt: str,
                                segment_count: int) -> List[str]:
        """GeminiÁøªËØë"""
        import asyncio

        def _sync_generate():
            response = self.client.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=self.config.max_tokens,
                    temperature=self.config.temperature,
                ))
            return response.text

        content = await asyncio.get_event_loop().run_in_executor(
            None, _sync_generate)

        self.api_calls += 1
        self.total_tokens += len(prompt) + len(content)  # ‰º∞ÁÆó

        return self._parse_translation_response(content, segment_count)

    async def _translate_openai_compatible(self, prompt: str,
                                           segment_count: int) -> List[str]:
        """OpenAIÂÖºÂÆπAPIÁøªËØë"""
        response = await self.client.chat.completions.create(
            model=self.config.model,
            messages=[{
                "role": "user",
                "content": prompt
            }],
            max_tokens=self.config.max_tokens,
            temperature=self.config.temperature)

        self.api_calls += 1
        if hasattr(response, 'usage') and response.usage:
            self.total_tokens += response.usage.total_tokens
        else:
            self.total_tokens += len(prompt) + len(
                response.choices[0].message.content)

        content = response.choices[0].message.content
        return self._parse_translation_response(content, segment_count)

    async def _translate_ollama(self, prompt: str,
                                segment_count: int) -> List[str]:
        """OllamaÁøªËØë"""
        payload = {
            "model": self.config.model,
            "prompt": prompt,
            "stream": False,
            "options": {
                "temperature": self.config.temperature,
                "num_predict": self.config.max_tokens
            }
        }

        async with self.session.post(f"{self.client['base_url']}/api/generate",
                                     json=payload) as response:
            if response.status == 200:
                data = await response.json()
                content = data.get('response', '')

                self.api_calls += 1
                self.total_tokens += len(prompt) + len(content)

                return self._parse_translation_response(content, segment_count)
            else:
                raise Exception(f"Ollama APIÈîôËØØ: {response.status}")

    def _parse_translation_response(self, content: str,
                                    expected_count: int) -> List[str]:
        """Ëß£ÊûêÁøªËØëÂìçÂ∫î"""
        lines = content.strip().split('\n')
        translations = []

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # ÁßªÈô§ÂèØËÉΩÁöÑÁºñÂè∑ÂâçÁºÄ
            line = re.sub(r'^\d+\.\s*', '', line)
            line = re.sub(r'^-\s*', '', line)  # ÁßªÈô§ÂàóË°®Á¨¶Âè∑
            translations.append(line)

        # Á°Æ‰øùËøîÂõûÊ≠£Á°ÆÊï∞ÈáèÁöÑÁøªËØë
        while len(translations) < expected_count:
            translations.append("")

        return translations[:expected_count]

    async def close(self):
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        if self.session:
            await self.session.close()


class SubtitleTranslationSystem:
    """Â≠óÂπïÁøªËØëÁ≥ªÁªü‰∏ªÁ±ª"""

    def __init__(self, workspace_dir: str = "subtitle_projects"):
        self.workspace = Path(workspace_dir)
        self.workspace.mkdir(exist_ok=True)

        # ÂÖ®Â±ÄÈÖçÁΩÆÊñá‰ª∂
        self.global_config_file = self.workspace / "global_config.json"
        self.load_global_config()

        # ÂàùÂßãÂåñLLMÂÆ¢Êà∑Á´ØÁÆ°ÁêÜÂô®
        self.client_manager = LLMClientManager()

    def load_global_config(self):
        """Âä†ËΩΩÂÖ®Â±ÄÈÖçÁΩÆ"""
        default_config = {
            "api_keys": {
                "openai": "",
                "anthropic": "",
                "gemini": "",
                "deepseek": "",
                "zhipu": "",
                "moonshot": "",
                "qwen": ""
            },
            "default_settings": {
                "llm_provider": "zhipu",
                "temperature": 0.3,
                "max_tokens": 2000,
                "batch_size": 10,
                "max_retry": 3
            }
        }

        # ‰ªéÊñá‰ª∂Âä†ËΩΩÈÖçÁΩÆ
        if self.global_config_file.exists():
            with open(self.global_config_file, 'r', encoding='utf-8') as f:
                self.global_config = json.load(f)
        else:
            self.global_config = default_config

        # ‰ªéÁéØÂ¢ÉÂèòÈáèË¶ÜÁõñAPIÂØÜÈí•
        env_mappings = {
            "openai": ["OPENAI_API_KEY", "OPENAI_KEY"],
            "anthropic": ["ANTHROPIC_API_KEY", "ANTHROPIC_KEY"],
            "gemini": ["GEMINI_API_KEY", "GOOGLE_API_KEY"],
            "deepseek": ["DEEPSEEK_API_KEY", "DEEPSEEK_KEY"],
            "zhipu": ["ZHIPU_API_KEY", "ZHIPU_KEY", "BIGMODEL_API_KEY"],
            "moonshot": ["MOONSHOT_API_KEY", "MOONSHOT_KEY"],
            "qwen": ["QWEN_API_KEY", "QWEN_KEY", "DASHSCOPE_API_KEY"]
        }

        for provider, env_vars in env_mappings.items():
            for env_var in env_vars:
                env_value = os.getenv(env_var)
                if env_value:
                    self.global_config["api_keys"][provider] = env_value
                    break

        # Â¶ÇÊûúÊñá‰ª∂‰∏çÂ≠òÂú®Ôºå‰øùÂ≠òÂêàÂπ∂ÂêéÁöÑÈÖçÁΩÆ
        if not self.global_config_file.exists():
            self.save_global_config()

    def save_global_config(self):
        """‰øùÂ≠òÂÖ®Â±ÄÈÖçÁΩÆ"""
        with open(self.global_config_file, 'w', encoding='utf-8') as f:
            json.dump(self.global_config, f, indent=2, ensure_ascii=False)

    def list_projects(self) -> List[str]:
        """ÂàóÂá∫ÊâÄÊúâÈ°πÁõÆ"""
        projects = []
        for project_dir in self.workspace.iterdir():
            if project_dir.is_dir() and (project_dir / "config.json").exists():
                projects.append(project_dir.name)
        return sorted(projects)

    def create_project(self, name: str, source_file: str,
                       config: Dict) -> TranslationProject:
        """ÂàõÂª∫Êñ∞È°πÁõÆ"""
        # È™åËØÅÈ°πÁõÆÂêçÁß∞
        if not re.match(r'^[a-zA-Z0-9_-]+$', name):
            raise ValueError("È°πÁõÆÂêçÁß∞Âè™ËÉΩÂåÖÂê´Â≠óÊØç„ÄÅÊï∞Â≠ó„ÄÅ‰∏ãÂàíÁ∫øÂíåÊ®™Á∫ø")

        project_dir = self.workspace / name
        if project_dir.exists():
            raise ValueError(f"È°πÁõÆ '{name}' Â∑≤Â≠òÂú®")

        # ÂêàÂπ∂ÂÖ®Â±ÄÈªòËÆ§ÈÖçÁΩÆ
        merged_config = {**self.global_config["default_settings"], **config}

        project_config = ProjectConfig(name=name,
                                       source_file=source_file,
                                       **merged_config)

        project = TranslationProject(project_config, project_dir)
        project.save_config()

        # Âä†ËΩΩÂ≠óÂπïÊñá‰ª∂
        self._load_subtitle_file(project, source_file)

        console.print(f"[green]‚úÖ È°πÁõÆ '{name}' ÂàõÂª∫ÊàêÂäü")
        return project

    def load_project(self, name: str) -> TranslationProject:
        """Âä†ËΩΩÁé∞ÊúâÈ°πÁõÆ"""
        project_dir = self.workspace / name
        config_file = project_dir / "config.json"

        if not config_file.exists():
            raise ValueError(f"È°πÁõÆ '{name}' ‰∏çÂ≠òÂú®")

        with open(config_file, 'r', encoding='utf-8') as f:
            config_data = json.load(f)

        project_config = ProjectConfig(**config_data)
        project = TranslationProject(project_config, project_dir)

        # Âä†ËΩΩÂ∑≤ÊúâÁöÑÁâáÊÆµÂíåËøõÂ∫¶
        project.load_segments()

        return project

    def _load_subtitle_file(self, project: TranslationProject, file_path: str):
        """Âä†ËΩΩÂ≠óÂπïÊñá‰ª∂Âà∞È°πÁõÆ"""
        try:
            # Â∞ùËØï‰∏çÂêåÁºñÁ†Å
            srt_file = None
            for encoding in ['utf-8', 'gbk', 'gb2312', 'latin1']:
                try:
                    srt_file = pysrt.open(file_path, encoding=encoding)
                    break
                except UnicodeDecodeError:
                    continue

            if srt_file is None:
                raise ValueError(f"Êó†Ê≥ïËß£Á†ÅÂ≠óÂπïÊñá‰ª∂: {file_path}")

            segments = []
            for item in srt_file:
                text = self._clean_subtitle_text(item.text)
                if text.strip():  # Ë∑≥ËøáÁ©∫Â≠óÂπï
                    # Ê≠£Á°ÆËΩ¨Êç¢ SubRipTime Âà∞ timedelta
                    start_td = timedelta(milliseconds=item.start.ordinal)
                    end_td = timedelta(milliseconds=item.end.ordinal)

                    segment = SubtitleSegment(index=item.index,
                                              start=start_td,
                                              end=end_td,
                                              text=text)
                    segments.append(segment)

            project.segments = segments
            project.save_segments()

            project.logger.info(f"Â∑≤Âä†ËΩΩ {len(segments)} ‰∏™Â≠óÂπïÁâáÊÆµ")

        except Exception as e:
            project.logger.error(f"Âä†ËΩΩÂ≠óÂπïÊñá‰ª∂Â§±Ë¥•: {e}")
            raise

    def _clean_subtitle_text(self, text: str) -> str:
        """Ê∏ÖÁêÜÂ≠óÂπïÊñáÊú¨"""
        # ÁßªÈô§HTMLÊ†áÁ≠æ
        text = re.sub(r'<[^>]+>', '', text)
        # ÁßªÈô§Â§ö‰ΩôÁ©∫ÁôΩ
        text = re.sub(r'\s+', ' ', text)
        # ÁßªÈô§Êç¢Ë°åÁ¨¶
        text = text.replace('\n', ' ').replace('\r', ' ')
        return text.strip()

    async def translate_project(self, project: TranslationProject,
                                api_key: str):
        """ÁøªËØëÈ°πÁõÆ"""
        engine = TranslationEngine(project)

        try:
            await engine.initialize(api_key)

            project.start_time = datetime.now()
            pending_segments = project.get_pending_segments()

            if not pending_segments:
                console.print("[yellow]‚ö†Ô∏è  Ê≤°ÊúâÂæÖÁøªËØëÁöÑÁâáÊÆµ")
                return

            console.print(f"[blue]üöÄ ÂºÄÂßãÁøªËØë {len(pending_segments)} ‰∏™ÁâáÊÆµ...")

            # ÂàõÂª∫ËøõÂ∫¶Êù°
            with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    BarColumn(),
                    TextColumn(
                        "[progress.percentage]{task.percentage:>3.0f}%"),
                    TimeRemainingColumn(),
                    console=console,
                    transient=True) as progress:

                task = progress.add_task(f"[green]ÁøªËØë‰∏≠...",
                                         total=len(pending_segments))

                # ÂàÜÊâπÂ§ÑÁêÜ
                batch_size = project.config.batch_size
                for i in range(0, len(pending_segments), batch_size):
                    batch = pending_segments[i:i + batch_size]

                    # ÁîüÊàê‰∏ä‰∏ãÊñá
                    context = self._generate_context(batch[0],
                                                     project.segments)

                    # ÁøªËØëÊâπÊ¨°
                    try:
                        translations = await engine.translate_batch(
                            batch, context)

                        # Â∫îÁî®ÁøªËØëÁªìÊûú
                        for segment, translation in zip(batch, translations):
                            if translation.strip():
                                segment.translation = translation
                                segment.status = TranslationStatus.COMPLETED
                            else:
                                segment.status = TranslationStatus.FAILED
                                segment.error_message = "ÁøªËØë‰∏∫Á©∫"

                        progress.update(task, advance=len(batch))

                        # ‰øùÂ≠òËøõÂ∫¶
                        project.save_segments()
                        project.save_progress()

                        # ÈÅøÂÖçAPIÈôêÂà∂
                        await asyncio.sleep(0.5)

                    except Exception as e:
                        project.logger.error(f"ÊâπÊ¨°ÁøªËØëÂ§±Ë¥•: {e}")
                        for segment in batch:
                            segment.status = TranslationStatus.FAILED
                            segment.error_message = str(e)
                            segment.retry_count += 1

            # ÂÆåÊàêÁªüËÆ°
            completed = len([
                s for s in project.segments
                if s.status == TranslationStatus.COMPLETED
            ])
            failed = len([
                s for s in project.segments
                if s.status == TranslationStatus.FAILED
            ])

            project.total_cost = self._calculate_cost(
                engine.total_tokens, project.config.llm_provider)
            project.save_progress()

            # ÊòæÁ§∫ÁªìÊûú
            self._show_translation_summary(project, engine, completed, failed)

        finally:
            await engine.close()

    def _generate_context(self, current_segment: SubtitleSegment,
                          all_segments: List[SubtitleSegment]) -> str:
        """ÁîüÊàê‰∏ä‰∏ãÊñá‰ø°ÊÅØ"""
        context_segments = []
        current_index = current_segment.index

        # Ëé∑ÂèñÂâçÈù¢ÁöÑÂ∑≤ÁøªËØëÁâáÊÆµ‰Ωú‰∏∫‰∏ä‰∏ãÊñá
        for segment in all_segments:
            if (segment.index < current_index
                    and segment.status == TranslationStatus.COMPLETED
                    and len(context_segments) < 5):
                context_segments.append(segment)

        if context_segments:
            context_text = " ".join([
                f"{seg.text} -> {seg.translation}"
                for seg in context_segments[-3:]
            ])
            return f"ÂâçÊñáÂØπÁÖß: {context_text}"

        return ""

    def _calculate_cost(self, tokens: int, provider: LLMProvider) -> float:
        """ËÆ°ÁÆóÁøªËØëÊàêÊú¨ÔºàUSDÔºâ"""
        cost_per_million = {
            LLMProvider.OPENAI: 0.15,  # gpt-4o-mini
            LLMProvider.ANTHROPIC: 3.0,  # claude-3.5-sonnet
            LLMProvider.GEMINI: 0.0,  # ÂÖçË¥πÈ¢ùÂ∫¶
            LLMProvider.DEEPSEEK: 0.14,  # Á∫¶$0.14/M tokens
            LLMProvider.ZHIPU: 0.014,  # Á∫¶$0.014/M tokens
            LLMProvider.MOONSHOT: 1.68,  # Á∫¶$1.68/M tokens
            LLMProvider.QWEN: 0.042,  # Á∫¶$0.042/M tokens
            LLMProvider.OLLAMA: 0.0  # ÂÖçË¥π
        }

        rate = cost_per_million.get(provider, 0.0)
        return (tokens / 1_000_000) * rate

    def _show_translation_summary(self, project: TranslationProject,
                                  engine: TranslationEngine, completed: int,
                                  failed: int):
        """ÊòæÁ§∫ÁøªËØëÊÄªÁªì"""
        table = Table(title=f"ÁøªËØëÂÆåÊàê - {project.config.name}")
        table.add_column("ÊåáÊ†á", style="cyan")
        table.add_column("Êï∞ÂÄº", style="green")

        table.add_row("ÊÄªÁâáÊÆµÊï∞", str(len(project.segments)))
        table.add_row("ÁøªËØëÊàêÂäü", str(completed))
        table.add_row("ÁøªËØëÂ§±Ë¥•", str(failed))
        table.add_row("ÂÆåÊàêÁéá", f"{project.get_completion_rate():.1f}%")
        table.add_row("APIË∞ÉÁî®Ê¨°Êï∞", str(engine.api_calls))
        table.add_row("ÊÄªTokenÊï∞", f"{engine.total_tokens:,}")
        table.add_row("È¢Ñ‰º∞ÊàêÊú¨", f"${project.total_cost:.4f}")

        console.print(table)

        if failed > 0:
            console.print(f"[yellow]‚ö†Ô∏è  {failed} ‰∏™ÁâáÊÆµÁøªËØëÂ§±Ë¥•ÔºåÂèØ‰ª•ÈáçËØï")

    def export_bilingual_subtitles(self, project: TranslationProject,
                                   output_path: str):
        """ÂØºÂá∫ÂèåËØ≠Â≠óÂπï"""
        srt_file = pysrt.SubRipFile()

        for segment in project.segments:
            if segment.status == TranslationStatus.COMPLETED:
                bilingual_text = f"{segment.text}\n{segment.translation}"
            else:
                bilingual_text = segment.text

            # Ê≠£Á°ÆËΩ¨Êç¢ timedelta Âà∞ SubRipTime
            start_ms = int(segment.start.total_seconds() * 1000)
            end_ms = int(segment.end.total_seconds() * 1000)

            item = pysrt.SubRipItem(
                index=segment.index,
                start=pysrt.SubRipTime.from_ordinal(start_ms),
                end=pysrt.SubRipTime.from_ordinal(end_ms),
                text=bilingual_text)
            srt_file.append(item)

        srt_file.save(output_path, encoding='utf-8')
        console.print(f"[green]‚úÖ ÂèåËØ≠Â≠óÂπïÂ∑≤ÂØºÂá∫: {output_path}")


# CLI ÂëΩ‰ª§ÂÆö‰πâ
@app.command("list")
def list_projects():
    """üìã ÂàóÂá∫ÊâÄÊúâÁøªËØëÈ°πÁõÆ"""
    system = SubtitleTranslationSystem()
    projects = system.list_projects()

    if not projects:
        console.print("[yellow]üìÅ Ê≤°ÊúâÊâæÂà∞ÁøªËØëÈ°πÁõÆ")
        console.print("üí° ‰ΩøÁî® 'create' ÂëΩ‰ª§ÂàõÂª∫Êñ∞È°πÁõÆ")
        return

    table = Table(title="üìÅ ÁøªËØëÈ°πÁõÆÂàóË°®")
    table.add_column("È°πÁõÆÂêçÁß∞", style="cyan")
    table.add_column("Áä∂ÊÄÅ", style="green")
    table.add_column("ÂÆåÊàêÁéá", style="yellow")
    table.add_column("ÊúÄÂêé‰øÆÊîπ", style="blue")

    for project_name in projects:
        try:
            project = system.load_project(project_name)
            completion_rate = project.get_completion_rate()

            # Âà§Êñ≠Áä∂ÊÄÅ
            if completion_rate == 100:
                status = "[green]‚úÖ Â∑≤ÂÆåÊàê[/green]"
            elif completion_rate > 0:
                status = "[yellow]üîÑ ËøõË°å‰∏≠[/yellow]"
            else:
                status = "[blue]üìù ÂæÖÂºÄÂßã[/blue]"

            # Ëé∑ÂèñÊúÄÂêé‰øÆÊîπÊó∂Èó¥
            config_file = project.project_dir / "config.json"
            mod_time = datetime.fromtimestamp(config_file.stat().st_mtime)
            mod_time_str = mod_time.strftime("%Y-%m-%d %H:%M")

            table.add_row(project_name, status, f"{completion_rate:.1f}%",
                          mod_time_str)

        except Exception as e:
            table.add_row(project_name, "[red]‚ùå ÈîôËØØ[/red]", "N/A", "N/A")

    console.print(table)


@app.command("create")
def create_project(
        name: str = typer.Argument(..., help="È°πÁõÆÂêçÁß∞"),
        source_file: str = typer.Argument(..., help="Ê∫êÂ≠óÂπïÊñá‰ª∂Ë∑ØÂæÑ"),
        provider: LLMProvider = typer.Option(LLMProvider.ZHIPU,
                                             "--provider",
                                             "-p",
                                             help="LLMÊèê‰æõÂïÜ"),
        model: str = typer.Option(None, "--model", "-m", help="Ê®°ÂûãÂêçÁß∞"),
        batch_size: int = typer.Option(10, "--batch", "-b", help="ÊâπÂ§ÑÁêÜÂ§ßÂ∞è"),
        temperature: float = typer.Option(0.3, "--temp", "-t", help="ÁøªËØëÊ∏©Â∫¶"),
):
    """üÜï ÂàõÂª∫Êñ∞ÁöÑÁøªËØëÈ°πÁõÆ"""

    # È™åËØÅÊ∫êÊñá‰ª∂
    if not Path(source_file).exists():
        console.print(f"[red]‚ùå Ê∫êÊñá‰ª∂‰∏çÂ≠òÂú®: {source_file}")
        raise typer.Exit(1)

    system = SubtitleTranslationSystem()

    # Ëé∑ÂèñÈªòËÆ§Ê®°Âûã
    if not model:
        model = system.client_manager.get_default_model(provider)

    config = {
        "llm_provider": provider,
        "model": model,
        "batch_size": batch_size,
        "temperature": temperature,
    }

    try:
        project = system.create_project(name, source_file, config)

        # ÊòæÁ§∫È°πÁõÆ‰ø°ÊÅØ
        provider_display = provider.value if hasattr(
            provider, 'value') else str(provider)
        panel = Panel(f"""
[bold green]È°πÁõÆÂàõÂª∫ÊàêÂäüÔºÅ[/bold green]

üìÅ È°πÁõÆÂêçÁß∞: {name}
üìÑ Ê∫êÊñá‰ª∂: {source_file}
ü§ñ LLMÊèê‰æõÂïÜ: {provider_display}
üéØ Ê®°Âûã: {model}
üìä Â≠óÂπïÁâáÊÆµ: {len(project.segments)}

üí° ‰∏ã‰∏ÄÊ≠•:
   1. ËÆæÁΩÆAPIÂØÜÈí•: subtitle-translator config set-key {provider_display} <your-key>
   2. ÂºÄÂßãÁøªËØë: subtitle-translator translate {name}
            """,
                      title="üéâ È°πÁõÆÂàõÂª∫ÂÆåÊàê",
                      border_style="green")
        console.print(panel)

    except Exception as e:
        console.print(f"[red]‚ùå ÂàõÂª∫È°πÁõÆÂ§±Ë¥•: {e}")
        raise typer.Exit(1)


@app.command("translate")
def translate_project(
        project_name: str = typer.Argument(..., help="È°πÁõÆÂêçÁß∞"),
        api_key: str = typer.Option(None, "--api-key", help="APIÂØÜÈí•Ôºà‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºâ"),
        resume: bool = typer.Option(False, "--resume", "-r", help="‰ªé‰∏äÊ¨°‰∏≠Êñ≠Â§ÑÁªßÁª≠"),
):
    """üöÄ ÂºÄÂßãÁøªËØëÈ°πÁõÆ"""

    system = SubtitleTranslationSystem()

    try:
        project = system.load_project(project_name)

        # Ëé∑ÂèñAPIÂØÜÈí• - ‰øÆÂ§çÊûö‰∏æÂÄºËÆøÈóÆÈóÆÈ¢ò
        if not api_key:
            # ÂÆâÂÖ®Âú∞Ëé∑ÂèñproviderÂêçÁß∞
            provider_name = project.config.llm_provider
            if hasattr(provider_name, 'value'):
                provider_name = provider_name.value

            api_key = system.global_config["api_keys"].get(provider_name)

            if not api_key:
                console.print(f"[red]‚ùå Êú™ËÆæÁΩÆ {provider_name} ÁöÑAPIÂØÜÈí•")
                console.print(
                    f"üí° ‰ΩøÁî®ÂëΩ‰ª§ËÆæÁΩÆ: python subtitle-translator.py config set-key {provider_name} <your-key>"
                )
                raise typer.Exit(1)

        # ÊòæÁ§∫ÁøªËØë‰ø°ÊÅØ
        if resume:
            console.print(f"[blue]üîÑ ÊÅ¢Â§çÁøªËØëÈ°πÁõÆ: {project_name}")
        else:
            console.print(f"[blue]üöÄ ÂºÄÂßãÁøªËØëÈ°πÁõÆ: {project_name}")

        # ÂºÇÊ≠•ËøêË°åÁøªËØë
        asyncio.run(system.translate_project(project, api_key))

    except Exception as e:
        console.print(f"[red]‚ùå ÁøªËØëÂ§±Ë¥•: {e}")
        logger.error(f"ÁøªËØëÈ°πÁõÆÂ§±Ë¥•: {e}", exc_info=True)
        raise typer.Exit(1)


@app.command("export")
def export_subtitles(project_name: str = typer.Argument(..., help="È°πÁõÆÂêçÁß∞"),
                     output_file: str = typer.Option(None,
                                                     "--output",
                                                     "-o",
                                                     help="ËæìÂá∫Êñá‰ª∂Ë∑ØÂæÑ"),
                     format_type: str = typer.Option(
                         "bilingual",
                         "--format",
                         "-f",
                         help="ÂØºÂá∫Ê†ºÂºè: bilingual, chinese, original")):
    """üì§ ÂØºÂá∫ÁøªËØëÂêéÁöÑÂ≠óÂπï"""

    system = SubtitleTranslationSystem()

    try:
        project = system.load_project(project_name)

        if not output_file:
            output_file = f"{project_name}_{format_type}.srt"

        if format_type == "bilingual":
            system.export_bilingual_subtitles(project, output_file)
        else:
            console.print(f"[yellow]‚ö†Ô∏è  Ê†ºÂºè '{format_type}' ÊöÇ‰∏çÊîØÊåÅÔºå‰ΩøÁî®ÂèåËØ≠Ê†ºÂºè")
            system.export_bilingual_subtitles(project, output_file)

    except Exception as e:
        console.print(f"[red]‚ùå ÂØºÂá∫Â§±Ë¥•: {e}")
        raise typer.Exit(1)


@app.command("status")
def show_project_status(project_name: str = typer.Argument(..., help="È°πÁõÆÂêçÁß∞")):
    """üìä Êü•ÁúãÈ°πÁõÆÁä∂ÊÄÅ"""

    system = SubtitleTranslationSystem()

    try:
        project = system.load_project(project_name)
        progress_data = project.load_progress()

        # ÁªüËÆ°‰ø°ÊÅØ
        total = len(project.segments)
        completed = len([
            s for s in project.segments
            if s.status == TranslationStatus.COMPLETED
        ])
        failed = len([
            s for s in project.segments if s.status == TranslationStatus.FAILED
        ])
        pending = total - completed - failed

        # ÂàõÂª∫Áä∂ÊÄÅË°®Ê†º
        table = Table(title=f"üìä È°πÁõÆÁä∂ÊÄÅ - {project_name}")
        table.add_column("ÊåáÊ†á", style="cyan")
        table.add_column("Êï∞ÂÄº", style="green")

        table.add_row("È°πÁõÆÂêçÁß∞", project.config.name)

        # ÂÆâÂÖ®Âú∞Ëé∑Âèñ provider ÂêçÁß∞
        provider_name = project.config.llm_provider
        if hasattr(provider_name, 'value'):
            provider_name = provider_name.value
        table.add_row("LLMÊèê‰æõÂïÜ", provider_name)

        table.add_row("Ê®°Âûã", project.config.model)
        table.add_row("ÊÄªÁâáÊÆµÊï∞", str(total))
        table.add_row("Â∑≤ÂÆåÊàê", f"{completed} ({completed/total*100:.1f}%)")
        table.add_row("ÁøªËØëÂ§±Ë¥•", str(failed))
        table.add_row("ÂæÖÂ§ÑÁêÜ", str(pending))

        if progress_data:
            if progress_data.get('start_time'):
                table.add_row("ÂºÄÂßãÊó∂Èó¥", progress_data['start_time'][:19])
            if progress_data.get('total_cost'):
                table.add_row("Â∑≤Ëä±Ë¥π", f"${progress_data['total_cost']:.4f}")

        console.print(table)

        # ÊòæÁ§∫Â§±Ë¥•ÁöÑÁâáÊÆµ
        if failed > 0:
            console.print(f"\n[yellow]‚ö†Ô∏è  Â§±Ë¥•ÁöÑÁâáÊÆµ:")
            failed_segments = project.get_failed_segments()
            for seg in failed_segments[:5]:  # Âè™ÊòæÁ§∫Ââç5‰∏™
                console.print(
                    f"  {seg.index}: {seg.text[:50]}... ({seg.error_message})")

            if len(failed_segments) > 5:
                console.print(f"  ... ËøòÊúâ {len(failed_segments) - 5} ‰∏™Â§±Ë¥•ÁâáÊÆµ")

    except Exception as e:
        console.print(f"[red]‚ùå Ëé∑ÂèñÁä∂ÊÄÅÂ§±Ë¥•: {e}")
        raise typer.Exit(1)


# ÈÖçÁΩÆÁÆ°ÁêÜÂ≠êÂëΩ‰ª§
config_app = typer.Typer(help="‚öôÔ∏è  ÈÖçÁΩÆÁÆ°ÁêÜ")
app.add_typer(config_app, name="config")


@config_app.command("set-key")
def set_api_key(provider: str = typer.Argument(..., help="LLMÊèê‰æõÂïÜ"),
                api_key: str = typer.Argument(..., help="APIÂØÜÈí•")):
    """üîë ËÆæÁΩÆAPIÂØÜÈí•"""

    system = SubtitleTranslationSystem()

    if provider not in system.global_config["api_keys"]:
        console.print(f"[red]‚ùå ‰∏çÊîØÊåÅÁöÑÊèê‰æõÂïÜ: {provider}")
        console.print(
            f"üí° ÊîØÊåÅÁöÑÊèê‰æõÂïÜ: {', '.join(system.global_config['api_keys'].keys())}")
        raise typer.Exit(1)

    system.global_config["api_keys"][provider] = api_key
    system.save_global_config()

    console.print(f"[green]‚úÖ Â∑≤ËÆæÁΩÆ {provider} ÁöÑAPIÂØÜÈí•")


@config_app.command("show")
def show_config():
    """üìã ÊòæÁ§∫ÂΩìÂâçÈÖçÁΩÆ"""

    system = SubtitleTranslationSystem()

    table = Table(title="‚öôÔ∏è  ÂÖ®Â±ÄÈÖçÁΩÆ")
    table.add_column("Êèê‰æõÂïÜ", style="cyan")
    table.add_column("APIÂØÜÈí•Áä∂ÊÄÅ", style="green")

    for provider, key in system.global_config["api_keys"].items():
        status = "[green]‚úÖ Â∑≤ËÆæÁΩÆ[/green]" if key else "[red]‚ùå Êú™ËÆæÁΩÆ[/red]"
        table.add_row(provider, status)

    console.print(table)


if __name__ == "__main__":
    app()
